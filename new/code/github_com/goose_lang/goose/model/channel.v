(* autogenerated from github.com/goose-lang/goose/model/channel *)
From New.golang Require Import defn.
Require Export New.code.github_com.goose_lang.primitive.
Require Export New.code.sync.

Definition channel : go_string := "github.com/goose-lang/goose/model/channel".

Module channel.
Section code.
Context `{ffi_syntax}.


Definition OfferState : go_type := uint64T.

Definition idle : expr := #(W64 0).

Definition offer : expr := #(W64 1).

Definition accepted : expr := #(W64 2).

Definition closed : expr := #(W64 3).

Definition Channel : val :=
  λ: "T", type.structT [
    (#"lock"%go, #ptrT);
    (#"state"%go, #OfferState);
    (#"buffer"%go, #sliceT);
    (#"cap"%go, #uint64T);
    (#"v"%go, #ptrT)
  ].

(* buffer_size = 0 is an unbuffered channel

   go: channel.go:32:6 *)
Definition NewChannelRef : val :=
  rec: "NewChannelRef" "T" "buffer_size" :=
    exception_do (let: "buffer_size" := (mem.alloc "buffer_size") in
    return: (mem.alloc (let: "$buffer" := (slice.make2 "T" #(W64 0)) in
     let: "$lock" := (mem.alloc (type.zero_val #sync.Mutex)) in
     let: "$cap" := (![#uint64T] "buffer_size") in
     let: "$state" := idle in
     struct.make (Channel "T") [{
       "lock" ::= "$lock";
       "state" ::= "$state";
       "buffer" ::= "$buffer";
       "cap" ::= "$cap";
       "v" ::= type.zero_val #ptrT
     }]))).

(* c.Send(val)

   is equivalent to:

   c <- val

   go: channel.go:46:22 *)
Definition Channel__Send : val :=
  rec: "Channel__Send" "c" "T" "val" :=
    exception_do (let: "c" := (mem.alloc "c") in
    let: "val" := (mem.alloc "val") in
    (if: (![#ptrT] "c") = #null
    then
      (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
        do:  #())
    else do:  #());;;
    let: "sendCase" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#ptrT] "c") in
    let: "$a1" := (!["T"] "val") in
    ((func_call #channel.channel #"NewSendCase"%go) "T") "$a0" "$a1") in
    do:  ("sendCase" <-[#ptrT] "$r0");;;
    do:  (let: "$a0" := (![#ptrT] "sendCase") in
    let: "$a1" := #true in
    ((func_call #channel.channel #"Select1"%go) "T") "$a0" "$a1");;;
    return: (#());;;
    return: #()).

Definition SelectDir : go_type := uint64T.

Definition SelectCase : val :=
  λ: "T", type.structT [
    (#"channel"%go, #ptrT);
    (#"dir"%go, #SelectDir);
    (#"Value"%go, "T");
    (#"Ok"%go, #boolT)
  ].

(* Equivalent to:
   value, ok := <-c
   Notably, this requires the user to consume the ok bool which is not actually required with Go
   channels. This should be able to be solved by adding an overload wrapper that discards the ok
   bool.

   go: channel.go:67:22 *)
Definition Channel__Receive : val :=
  rec: "Channel__Receive" "c" "T" <> :=
    exception_do (let: "c" := (mem.alloc "c") in
    (if: (![#ptrT] "c") = #null
    then
      (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
        do:  #())
    else do:  #());;;
    let: "recvCase" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#ptrT] "c") in
    ((func_call #channel.channel #"NewRecvCase"%go) "T") "$a0") in
    do:  ("recvCase" <-[#ptrT] "$r0");;;
    do:  (let: "$a0" := (![#ptrT] "recvCase") in
    let: "$a1" := #true in
    ((func_call #channel.channel #"Select1"%go) "T") "$a0" "$a1");;;
    return: (!["T"] (struct.field_ref (SelectCase "T") #"Value"%go (![#ptrT] "recvCase")), ![#boolT] (struct.field_ref (SelectCase "T") #"Ok"%go (![#ptrT] "recvCase")))).

(* This is a non-blocking attempt at closing. The only reason close blocks ever is because there
   may be successful exchanges that need to complete, which is equivalent to the go runtime where
   the closer must still obtain the channel's lock

   go: channel.go:87:22 *)
Definition Channel__TryClose : val :=
  rec: "Channel__TryClose" "c" "T" <> :=
    exception_do (let: "c" := (mem.alloc "c") in
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    (if: (![#OfferState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = closed
    then
      do:  (let: "$a0" := (interface.make #""%go #"string"%go #"close of closed channel"%go) in
      Panic "$a0")
    else do:  #());;;
    (if: (![#OfferState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = idle
    then
      let: "$r0" := closed in
      do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#OfferState] "$r0");;;
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      return: (#true)
    else do:  #());;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    return: (#false)).

(* c.Close()

   is equivalent to:

   close(c)

   go: channel.go:108:22 *)
Definition Channel__Close : val :=
  rec: "Channel__Close" "c" "T" <> :=
    exception_do (let: "c" := (mem.alloc "c") in
    (if: (![#ptrT] "c") = #null
    then
      do:  (let: "$a0" := (interface.make #""%go #"string"%go #"close of nil channel"%go) in
      Panic "$a0")
    else do:  #());;;
    let: "done" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #false in
    do:  ("done" <-[#boolT] "$r0");;;
    (for: (λ: <>, (~ (![#boolT] "done"))); (λ: <>, Skip) := λ: <>,
      let: "$r0" := ((method_call #channel.channel #"Channel'ptr" #"TryClose" (![#ptrT] "c") "T") #()) in
      do:  ("done" <-[#boolT] "$r0"));;;
    return: #()).

(* v := c.ReceiveDiscardOk

   is equivalent to:
   v := c<-
   It seems like Go requires ignored return values to be annotated with _ but channels don't
   require this so this will need to be translated.

   go: channel.go:124:22 *)
Definition Channel__ReceiveDiscardOk : val :=
  rec: "Channel__ReceiveDiscardOk" "c" "T" <> :=
    exception_do (let: "c" := (mem.alloc "c") in
    let: "return_val" := (mem.alloc (type.zero_val "T")) in
    let: ("$ret0", "$ret1") := ((method_call #channel.channel #"Channel'ptr" #"Receive" (![#ptrT] "c") "T") #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("return_val" <-["T"] "$r0");;;
    do:  "$r1";;;
    return: (!["T"] "return_val")).

(* If there is a value available in the buffer, consume it, otherwise, don't select.

   go: channel.go:131:22 *)
Definition Channel__BufferedTryReceive : val :=
  rec: "Channel__BufferedTryReceive" "c" "T" <> :=
    exception_do (let: "c" := (mem.alloc "c") in
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    let: "v" := (mem.alloc (type.zero_val "T")) in
    (if: int_gt (let: "$a0" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
    slice.len "$a0") #(W64 0)
    then
      let: "val_copy" := (mem.alloc (type.zero_val "T")) in
      let: "$r0" := (!["T"] (slice.elem_ref "T" (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) #(W64 0))) in
      do:  ("val_copy" <-["T"] "$r0");;;
      let: "$r0" := (let: "$s" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
      slice.slice "T" "$s" #(W64 1) (slice.len "$s")) in
      do:  ((struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c")) <-[#sliceT] "$r0");;;
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      return: (#true, !["T"] "val_copy", #true)
    else do:  #());;;
    (if: (![#OfferState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = closed
    then
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      return: (#true, !["T"] "v", #false)
    else do:  #());;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    return: (#false, !["T"] "v", #true)).

(* go: channel.go:148:22 *)
Definition Channel__UnbufferedTryReceive : val :=
  rec: "Channel__UnbufferedTryReceive" "c" "T" "blocking" :=
    exception_do (let: "c" := (mem.alloc "c") in
    let: "blocking" := (mem.alloc "blocking") in
    let: "local_val" := (mem.alloc (type.zero_val "T")) in
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    (if: (![#OfferState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = closed
    then
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      return: (#true, !["T"] "local_val", #false)
    else do:  #());;;
    (if: ((![#OfferState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = offer) && ((![#ptrT] (struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c"))) ≠ #null)
    then
      let: "$r0" := (!["T"] (![#ptrT] (struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c")))) in
      do:  ("local_val" <-["T"] "$r0");;;
      let: "$r0" := accepted in
      do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#OfferState] "$r0");;;
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      return: (#true, !["T"] "local_val", #true)
    else do:  #());;;
    (if: ((![#OfferState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = idle) && (![#boolT] "blocking")
    then
      let: "$r0" := offer in
      do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#OfferState] "$r0");;;
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      (if: (![#OfferState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = closed
      then
        do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
        return: (#true, !["T"] "local_val", #false)
      else do:  #());;;
      (if: (![#OfferState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = offer
      then
        let: "$r0" := idle in
        do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#OfferState] "$r0");;;
        do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
        return: (#false, !["T"] "local_val", #true)
      else do:  #());;;
      (if: (![#OfferState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = accepted
      then
        let: "$r0" := idle in
        do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#OfferState] "$r0");;;
        let: "$r0" := (!["T"] (![#ptrT] (struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c")))) in
        do:  ("local_val" <-["T"] "$r0");;;
        let: "$r0" := #null in
        do:  ((struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c")) <-[#ptrT] "$r0");;;
        do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
        return: (#true, !["T"] "local_val", #true)
      else do:  #());;;
      do:  (let: "$a0" := (interface.make #""%go #"string"%go #"not supposed to be here!"%go) in
      Panic "$a0")
    else do:  #());;;
    (if: (((![#OfferState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = accepted) || ((![#OfferState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = offer)) || (~ (![#boolT] "blocking"))
    then
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      return: (#false, !["T"] "local_val", #true)
    else do:  #());;;
    do:  (let: "$a0" := (interface.make #""%go #"string"%go #"not supposed to be here!"%go) in
    Panic "$a0")).

(* Non-blocking receive function used for select statements. Blocking receive is modeled as
   a single blocking select statement which amounts to a for loop until selected.
   The blocking parameter here is used to determine whether or not we will make an offer to a
   waiting sender. If true, we will make an offer since blocking receive is modeled as a for loop
   around nonblocking TryReceive. If false, we don't make an offer since we don't need to match
   with another non-blocking send.

   go: channel.go:206:22 *)
Definition Channel__TryReceive : val :=
  rec: "Channel__TryReceive" "c" "T" "blocking" :=
    exception_do (let: "c" := (mem.alloc "c") in
    let: "blocking" := (mem.alloc "blocking") in
    (if: (![#uint64T] (struct.field_ref (Channel "T") #"cap"%go (![#ptrT] "c"))) > #(W64 0)
    then
      let: (("$ret0", "$ret1"), "$ret2") := (((method_call #channel.channel #"Channel'ptr" #"BufferedTryReceive" (![#ptrT] "c") "T") #())) in
      return: ("$ret0", "$ret1", "$ret2")
    else
      let: (("$ret0", "$ret1"), "$ret2") := ((let: "$a0" := (![#boolT] "blocking") in
      (method_call #channel.channel #"Channel'ptr" #"UnbufferedTryReceive" (![#ptrT] "c") "T") "$a0")) in
      return: ("$ret0", "$ret1", "$ret2"))).

(* go: channel.go:214:22 *)
Definition Channel__UnbufferedTrySend : val :=
  rec: "Channel__UnbufferedTrySend" "c" "T" "val" "blocking" :=
    exception_do (let: "c" := (mem.alloc "c") in
    let: "blocking" := (mem.alloc "blocking") in
    let: "val" := (mem.alloc "val") in
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    (if: (![#OfferState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = closed
    then
      do:  (let: "$a0" := (interface.make #""%go #"string"%go #"send on closed channel"%go) in
      Panic "$a0")
    else do:  #());;;
    (if: ((![#OfferState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = offer) && ((![#ptrT] (struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c"))) = #null)
    then
      let: "$r0" := (mem.alloc (type.zero_val "T")) in
      do:  ((struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c")) <-[#ptrT] "$r0");;;
      let: "$r0" := accepted in
      do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#OfferState] "$r0");;;
      let: "$r0" := (!["T"] "val") in
      do:  ((![#ptrT] (struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c"))) <-["T"] "$r0");;;
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      return: (#true)
    else do:  #());;;
    (if: ((![#OfferState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = idle) && (![#boolT] "blocking")
    then
      let: "$r0" := (mem.alloc (type.zero_val "T")) in
      do:  ((struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c")) <-[#ptrT] "$r0");;;
      let: "$r0" := offer in
      do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#OfferState] "$r0");;;
      let: "$r0" := (!["T"] "val") in
      do:  ((![#ptrT] (struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c"))) <-["T"] "$r0");;;
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      (if: (![#OfferState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = accepted
      then
        let: "$r0" := idle in
        do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#OfferState] "$r0");;;
        let: "$r0" := #null in
        do:  ((struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c")) <-[#ptrT] "$r0");;;
        do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
        return: (#true)
      else do:  #());;;
      (if: (![#OfferState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = offer
      then
        let: "$r0" := idle in
        do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#OfferState] "$r0");;;
        let: "$r0" := #null in
        do:  ((struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c")) <-[#ptrT] "$r0");;;
        do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
        return: (#false)
      else do:  #());;;
      do:  (let: "$a0" := (interface.make #""%go #"string"%go #"Invalid state transition with open receive offer"%go) in
      Panic "$a0")
    else do:  #());;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    return: (#false)).

(* If the buffer has free space, push our value.

   go: channel.go:258:22 *)
Definition Channel__BufferedTrySend : val :=
  rec: "Channel__BufferedTrySend" "c" "T" "val" :=
    exception_do (let: "c" := (mem.alloc "c") in
    let: "val" := (mem.alloc "val") in
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    (if: (![#OfferState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = closed
    then
      do:  (let: "$a0" := (interface.make #""%go #"string"%go #"send on closed channel"%go) in
      Panic "$a0")
    else do:  #());;;
    (if: int_lt (let: "$a0" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
    slice.len "$a0") (u_to_w64 (![#uint64T] (struct.field_ref (Channel "T") #"cap"%go (![#ptrT] "c"))))
    then
      let: "$r0" := (let: "$a0" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
      let: "$a1" := ((let: "$sl0" := (!["T"] "val") in
      slice.literal "T" ["$sl0"])) in
      (slice.append "T") "$a0" "$a1") in
      do:  ((struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c")) <-[#sliceT] "$r0");;;
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      return: (#true)
    else do:  #());;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    return: (#false)).

(* Non-Blocking send operation for select statements. Blocking send and blocking select
   statements simply call this in a for loop until it returns true.

   go: channel.go:276:22 *)
Definition Channel__TrySend : val :=
  rec: "Channel__TrySend" "c" "T" "val" "blocking" :=
    exception_do (let: "c" := (mem.alloc "c") in
    let: "blocking" := (mem.alloc "blocking") in
    let: "val" := (mem.alloc "val") in
    let: "sendResult" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #false in
    do:  ("sendResult" <-[#boolT] "$r0");;;
    (if: (![#uint64T] (struct.field_ref (Channel "T") #"cap"%go (![#ptrT] "c"))) ≠ #(W64 0)
    then
      let: "$r0" := (let: "$a0" := (!["T"] "val") in
      (method_call #channel.channel #"Channel'ptr" #"BufferedTrySend" (![#ptrT] "c") "T") "$a0") in
      do:  ("sendResult" <-[#boolT] "$r0")
    else
      let: "$r0" := (let: "$a0" := (!["T"] "val") in
      let: "$a1" := (![#boolT] "blocking") in
      (method_call #channel.channel #"Channel'ptr" #"UnbufferedTrySend" (![#ptrT] "c") "T") "$a0" "$a1") in
      do:  ("sendResult" <-[#boolT] "$r0"));;;
    return: (![#boolT] "sendResult")).

(* c.Len()

   is equivalent to:
   len(c)

   This might not be worth specifying since it is hard to make good use of channel length
   semantics.

   go: channel.go:295:22 *)
Definition Channel__Len : val :=
  rec: "Channel__Len" "c" "T" <> :=
    exception_do (let: "c" := (mem.alloc "c") in
    (if: (![#ptrT] "c") = #null
    then return: (#(W64 0))
    else do:  #());;;
    let: "chan_len" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("chan_len" <-[#uint64T] "$r0");;;
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    let: "$r0" := (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
    slice.len "$a0")) in
    do:  ("chan_len" <-[#uint64T] "$r0");;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    return: (![#uint64T] "chan_len")).

(* c.Cap()

   is equivalent to:
   cap(c)

   go: channel.go:310:22 *)
Definition Channel__Cap : val :=
  rec: "Channel__Cap" "c" "T" <> :=
    exception_do (let: "c" := (mem.alloc "c") in
    (if: (![#ptrT] "c") = #null
    then return: (#(W64 0))
    else do:  #());;;
    return: (![#uint64T] (struct.field_ref (Channel "T") #"cap"%go (![#ptrT] "c")))).

(* case Chan <- Send *)
Definition SelectSend : expr := #(W64 0).

(* case <-Chan: *)
Definition SelectRecv : expr := #(W64 1).

(* go: channel.go:336:6 *)
Definition NewSendCase : val :=
  rec: "NewSendCase" "T" "channel" "value" :=
    exception_do (let: "value" := (mem.alloc "value") in
    let: "channel" := (mem.alloc "channel") in
    return: (mem.alloc (let: "$channel" := (![#ptrT] "channel") in
     let: "$dir" := SelectSend in
     let: "$Value" := (!["T"] "value") in
     struct.make (SelectCase "T") [{
       "channel" ::= "$channel";
       "dir" ::= "$dir";
       "Value" ::= "$Value";
       "Ok" ::= type.zero_val #boolT
     }]))).

(* go: channel.go:344:6 *)
Definition NewRecvCase : val :=
  rec: "NewRecvCase" "T" "channel" :=
    exception_do (let: "channel" := (mem.alloc "channel") in
    return: (mem.alloc (let: "$channel" := (![#ptrT] "channel") in
     let: "$dir" := SelectRecv in
     struct.make (SelectCase "T") [{
       "channel" ::= "$channel";
       "dir" ::= "$dir";
       "Value" ::= type.zero_val "T";
       "Ok" ::= type.zero_val #boolT
     }]))).

(* Uses the applicable Try<Operation> function on the select case's channel. Default is always
   selectable so simply returns true.

   go: channel.go:353:6 *)
Definition TrySelect : val :=
  rec: "TrySelect" "T" "select_case" "blocking" :=
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "select_case" := (mem.alloc "select_case") in
    let: "channel" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (![#ptrT] (struct.field_ref (SelectCase "T") #"channel"%go (![#ptrT] "select_case"))) in
    do:  ("channel" <-[#ptrT] "$r0");;;
    (if: (![#ptrT] "channel") = #null
    then return: (#false)
    else do:  #());;;
    (if: (![#SelectDir] (struct.field_ref (SelectCase "T") #"dir"%go (![#ptrT] "select_case"))) = SelectSend
    then
      return: (let: "$a0" := (!["T"] (struct.field_ref (SelectCase "T") #"Value"%go (![#ptrT] "select_case"))) in
       let: "$a1" := (![#boolT] "blocking") in
       (method_call #channel.channel #"Channel'ptr" #"TrySend" (![#ptrT] "channel") "T") "$a0" "$a1")
    else do:  #());;;
    (if: (![#SelectDir] (struct.field_ref (SelectCase "T") #"dir"%go (![#ptrT] "select_case"))) = SelectRecv
    then
      let: "item" := (mem.alloc (type.zero_val "T")) in
      let: "ok" := (mem.alloc (type.zero_val #boolT)) in
      let: "selected" := (mem.alloc (type.zero_val #boolT)) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#boolT] "blocking") in
      (method_call #channel.channel #"Channel'ptr" #"TryReceive" (![#ptrT] "channel") "T") "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("selected" <-[#boolT] "$r0");;;
      do:  ("item" <-["T"] "$r1");;;
      do:  ("ok" <-[#boolT] "$r2");;;
      let: "$r0" := (!["T"] "item") in
      do:  ((struct.field_ref (SelectCase "T") #"Value"%go (![#ptrT] "select_case")) <-["T"] "$r0");;;
      let: "$r0" := (![#boolT] "ok") in
      do:  ((struct.field_ref (SelectCase "T") #"Ok"%go (![#ptrT] "select_case")) <-[#boolT] "$r0");;;
      return: (![#boolT] "selected")
    else do:  #());;;
    return: (#false)).

(* Select1 performs a select operation on 1 case. This is used for Send and
   Receive as well, since these channel operations in Go are equivalent to
   a single case select statement with no default.

   go: channel.go:380:6 *)
Definition Select1 : val :=
  rec: "Select1" "T1" "case1" "blocking" :=
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "case1" := (mem.alloc "case1") in
    let: "selected" := (mem.alloc (type.zero_val #boolT)) in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "$r0" := (let: "$a0" := (![#ptrT] "case1") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #channel.channel #"TrySelect"%go) "T1") "$a0" "$a1") in
      do:  ("selected" <-[#boolT] "$r0");;;
      (if: (![#boolT] "selected") || (~ (![#boolT] "blocking"))
      then break: #()
      else do:  #()));;;
    return: (![#boolT] "selected")).

(* go: channel.go:393:6 *)
Definition TrySelectCase2 : val :=
  rec: "TrySelectCase2" "T1" "T2" "index" "case1" "case2" "blocking" :=
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "index" := (mem.alloc "index") in
    (if: (![#uint64T] "index") = #(W64 0)
    then
      return: (let: "$a0" := (![#ptrT] "case1") in
       let: "$a1" := (![#boolT] "blocking") in
       ((func_call #channel.channel #"TrySelect"%go) "T1") "$a0" "$a1")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 1)
    then
      return: (let: "$a0" := (![#ptrT] "case2") in
       let: "$a1" := (![#boolT] "blocking") in
       ((func_call #channel.channel #"TrySelect"%go) "T2") "$a0" "$a1")
    else do:  #());;;
    do:  (let: "$a0" := (interface.make #""%go #"string"%go #"index needs to be 0 or 1"%go) in
    Panic "$a0")).

(* go: channel.go:406:6 *)
Definition Select2 : val :=
  rec: "Select2" "T1" "T2" "case1" "case2" "blocking" :=
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (((func_call #primitive.primitive #"RandomUint64"%go) #()) `rem` #(W64 2)) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (if: let: "$a0" := (![#uint64T] "i") in
    let: "$a1" := (![#ptrT] "case1") in
    let: "$a2" := (![#ptrT] "case2") in
    let: "$a3" := (![#boolT] "blocking") in
    ((func_call #channel.channel #"TrySelectCase2"%go) "T1" "T2") "$a0" "$a1" "$a2" "$a3"
    then return: (![#uint64T] "i")
    else do:  #());;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: let: "$a0" := (![#ptrT] "case1") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #channel.channel #"TrySelect"%go) "T1") "$a0" "$a1"
      then return: (#(W64 0))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case2") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #channel.channel #"TrySelect"%go) "T2") "$a0" "$a1"
      then return: (#(W64 1))
      else do:  #());;;
      (if: (~ (![#boolT] "blocking"))
      then return: (#(W64 2))
      else do:  #()))).

(* go: channel.go:430:6 *)
Definition TrySelectCase3 : val :=
  rec: "TrySelectCase3" "T1" "T2" "T3" "index" "case1" "case2" "case3" "blocking" :=
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "case3" := (mem.alloc "case3") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "index" := (mem.alloc "index") in
    (if: (![#uint64T] "index") = #(W64 0)
    then
      return: (let: "$a0" := (![#ptrT] "case1") in
       let: "$a1" := (![#boolT] "blocking") in
       ((func_call #channel.channel #"TrySelect"%go) "T1") "$a0" "$a1")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 1)
    then
      return: (let: "$a0" := (![#ptrT] "case2") in
       let: "$a1" := (![#boolT] "blocking") in
       ((func_call #channel.channel #"TrySelect"%go) "T2") "$a0" "$a1")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 2)
    then
      return: (let: "$a0" := (![#ptrT] "case3") in
       let: "$a1" := (![#boolT] "blocking") in
       ((func_call #channel.channel #"TrySelect"%go) "T3") "$a0" "$a1")
    else do:  #());;;
    do:  (let: "$a0" := (interface.make #""%go #"string"%go #"index needs to be 0, 1 or 2"%go) in
    Panic "$a0")).

(* go: channel.go:447:6 *)
Definition Select3 : val :=
  rec: "Select3" "T1" "T2" "T3" "case1" "case2" "case3" "blocking" :=
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "case3" := (mem.alloc "case3") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (((func_call #primitive.primitive #"RandomUint64"%go) #()) `rem` #(W64 3)) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (if: let: "$a0" := (![#uint64T] "i") in
    let: "$a1" := (![#ptrT] "case1") in
    let: "$a2" := (![#ptrT] "case2") in
    let: "$a3" := (![#ptrT] "case3") in
    let: "$a4" := (![#boolT] "blocking") in
    ((func_call #channel.channel #"TrySelectCase3"%go) "T1" "T2" "T3") "$a0" "$a1" "$a2" "$a3" "$a4"
    then return: (![#uint64T] "i")
    else do:  #());;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: let: "$a0" := (![#ptrT] "case1") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #channel.channel #"TrySelect"%go) "T1") "$a0" "$a1"
      then return: (#(W64 0))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case2") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #channel.channel #"TrySelect"%go) "T2") "$a0" "$a1"
      then return: (#(W64 1))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case3") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #channel.channel #"TrySelect"%go) "T3") "$a0" "$a1"
      then return: (#(W64 2))
      else do:  #());;;
      (if: (~ (![#boolT] "blocking"))
      then return: (#(W64 3))
      else do:  #()))).

(* go: channel.go:474:6 *)
Definition TrySelectCase4 : val :=
  rec: "TrySelectCase4" "T1" "T2" "T3" "T4" "index" "case1" "case2" "case3" "case4" "blocking" :=
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "case4" := (mem.alloc "case4") in
    let: "case3" := (mem.alloc "case3") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "index" := (mem.alloc "index") in
    (if: (![#uint64T] "index") = #(W64 0)
    then
      return: (let: "$a0" := (![#ptrT] "case1") in
       let: "$a1" := (![#boolT] "blocking") in
       ((func_call #channel.channel #"TrySelect"%go) "T1") "$a0" "$a1")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 1)
    then
      return: (let: "$a0" := (![#ptrT] "case2") in
       let: "$a1" := (![#boolT] "blocking") in
       ((func_call #channel.channel #"TrySelect"%go) "T2") "$a0" "$a1")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 2)
    then
      return: (let: "$a0" := (![#ptrT] "case3") in
       let: "$a1" := (![#boolT] "blocking") in
       ((func_call #channel.channel #"TrySelect"%go) "T3") "$a0" "$a1")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 3)
    then
      return: (let: "$a0" := (![#ptrT] "case4") in
       let: "$a1" := (![#boolT] "blocking") in
       ((func_call #channel.channel #"TrySelect"%go) "T4") "$a0" "$a1")
    else do:  #());;;
    do:  (let: "$a0" := (interface.make #""%go #"string"%go #"index needs to be 0, 1, 2 or 3"%go) in
    Panic "$a0")).

(* go: channel.go:495:6 *)
Definition Select4 : val :=
  rec: "Select4" "T1" "T2" "T3" "T4" "case1" "case2" "case3" "case4" "blocking" :=
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "case4" := (mem.alloc "case4") in
    let: "case3" := (mem.alloc "case3") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (((func_call #primitive.primitive #"RandomUint64"%go) #()) `rem` #(W64 4)) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (if: let: "$a0" := (![#uint64T] "i") in
    let: "$a1" := (![#ptrT] "case1") in
    let: "$a2" := (![#ptrT] "case2") in
    let: "$a3" := (![#ptrT] "case3") in
    let: "$a4" := (![#ptrT] "case4") in
    let: "$a5" := (![#boolT] "blocking") in
    ((func_call #channel.channel #"TrySelectCase4"%go) "T1" "T2" "T3" "T4") "$a0" "$a1" "$a2" "$a3" "$a4" "$a5"
    then return: (![#uint64T] "i")
    else do:  #());;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: let: "$a0" := (![#ptrT] "case1") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #channel.channel #"TrySelect"%go) "T1") "$a0" "$a1"
      then return: (#(W64 0))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case2") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #channel.channel #"TrySelect"%go) "T2") "$a0" "$a1"
      then return: (#(W64 1))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case3") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #channel.channel #"TrySelect"%go) "T3") "$a0" "$a1"
      then return: (#(W64 2))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case4") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #channel.channel #"TrySelect"%go) "T4") "$a0" "$a1"
      then return: (#(W64 3))
      else do:  #());;;
      (if: (~ (![#boolT] "blocking"))
      then return: (#(W64 4))
      else do:  #()))).

(* go: channel.go:526:6 *)
Definition TrySelectCase5 : val :=
  rec: "TrySelectCase5" "T1" "T2" "T3" "T4" "T5" "index" "case1" "case2" "case3" "case4" "case5" "blocking" :=
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "case5" := (mem.alloc "case5") in
    let: "case4" := (mem.alloc "case4") in
    let: "case3" := (mem.alloc "case3") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "index" := (mem.alloc "index") in
    (if: (![#uint64T] "index") = #(W64 0)
    then
      return: (let: "$a0" := (![#ptrT] "case1") in
       let: "$a1" := (![#boolT] "blocking") in
       ((func_call #channel.channel #"TrySelect"%go) "T1") "$a0" "$a1")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 1)
    then
      return: (let: "$a0" := (![#ptrT] "case2") in
       let: "$a1" := (![#boolT] "blocking") in
       ((func_call #channel.channel #"TrySelect"%go) "T2") "$a0" "$a1")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 2)
    then
      return: (let: "$a0" := (![#ptrT] "case3") in
       let: "$a1" := (![#boolT] "blocking") in
       ((func_call #channel.channel #"TrySelect"%go) "T3") "$a0" "$a1")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 3)
    then
      return: (let: "$a0" := (![#ptrT] "case4") in
       let: "$a1" := (![#boolT] "blocking") in
       ((func_call #channel.channel #"TrySelect"%go) "T4") "$a0" "$a1")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 4)
    then
      return: (let: "$a0" := (![#ptrT] "case5") in
       let: "$a1" := (![#boolT] "blocking") in
       ((func_call #channel.channel #"TrySelect"%go) "T5") "$a0" "$a1")
    else do:  #());;;
    do:  (let: "$a0" := (interface.make #""%go #"string"%go #"index needs to be 0, 1, 2, 3 or 4"%go) in
    Panic "$a0")).

(* go: channel.go:551:6 *)
Definition Select5 : val :=
  rec: "Select5" "T1" "T2" "T3" "T4" "T5" "case1" "case2" "case3" "case4" "case5" "blocking" :=
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "case5" := (mem.alloc "case5") in
    let: "case4" := (mem.alloc "case4") in
    let: "case3" := (mem.alloc "case3") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (((func_call #primitive.primitive #"RandomUint64"%go) #()) `rem` #(W64 5)) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (if: let: "$a0" := (![#uint64T] "i") in
    let: "$a1" := (![#ptrT] "case1") in
    let: "$a2" := (![#ptrT] "case2") in
    let: "$a3" := (![#ptrT] "case3") in
    let: "$a4" := (![#ptrT] "case4") in
    let: "$a5" := (![#ptrT] "case5") in
    let: "$a6" := (![#boolT] "blocking") in
    ((func_call #channel.channel #"TrySelectCase5"%go) "T1" "T2" "T3" "T4" "T5") "$a0" "$a1" "$a2" "$a3" "$a4" "$a5" "$a6"
    then return: (![#uint64T] "i")
    else do:  #());;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: let: "$a0" := (![#ptrT] "case1") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #channel.channel #"TrySelect"%go) "T1") "$a0" "$a1"
      then return: (#(W64 0))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case2") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #channel.channel #"TrySelect"%go) "T2") "$a0" "$a1"
      then return: (#(W64 1))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case3") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #channel.channel #"TrySelect"%go) "T3") "$a0" "$a1"
      then return: (#(W64 2))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case4") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #channel.channel #"TrySelect"%go) "T4") "$a0" "$a1"
      then return: (#(W64 3))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case5") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #channel.channel #"TrySelect"%go) "T5") "$a0" "$a1"
      then return: (#(W64 4))
      else do:  #());;;
      (if: (~ (![#boolT] "blocking"))
      then return: (#(W64 5))
      else do:  #()))).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [("NewChannelRef"%go, NewChannelRef); ("NewSendCase"%go, NewSendCase); ("NewRecvCase"%go, NewRecvCase); ("TrySelect"%go, TrySelect); ("Select1"%go, Select1); ("TrySelectCase2"%go, TrySelectCase2); ("Select2"%go, Select2); ("TrySelectCase3"%go, TrySelectCase3); ("Select3"%go, Select3); ("TrySelectCase4"%go, TrySelectCase4); ("Select4"%go, Select4); ("TrySelectCase5"%go, TrySelectCase5); ("Select5"%go, Select5)].

Definition msets' : list (go_string * (list (go_string * val))) := [("OfferState"%go, []); ("OfferState'ptr"%go, []); ("Channel"%go, []); ("Channel'ptr"%go, [("BufferedTryReceive"%go, Channel__BufferedTryReceive); ("BufferedTrySend"%go, Channel__BufferedTrySend); ("Cap"%go, Channel__Cap); ("Close"%go, Channel__Close); ("Len"%go, Channel__Len); ("Receive"%go, Channel__Receive); ("ReceiveDiscardOk"%go, Channel__ReceiveDiscardOk); ("Send"%go, Channel__Send); ("TryClose"%go, Channel__TryClose); ("TryReceive"%go, Channel__TryReceive); ("TrySend"%go, Channel__TrySend); ("UnbufferedTryReceive"%go, Channel__UnbufferedTryReceive); ("UnbufferedTrySend"%go, Channel__UnbufferedTrySend)]); ("SelectDir"%go, []); ("SelectDir'ptr"%go, []); ("SelectCase"%go, []); ("SelectCase'ptr"%go, [])].

#[global] Instance info' : PkgInfo channel.channel :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [sync.sync; primitive.primitive];
  |}.

Definition initialize' : val :=
  rec: "initialize'" <> :=
    globals.package_init channel.channel (λ: <>,
      exception_do (do:  primitive.initialize';;;
      do:  sync.initialize')
      ).

End code.
End channel.
